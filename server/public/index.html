<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IoT Device Monitor</title>
    <!-- Add Leaflet for maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Add Chart.js for graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f2f5;
        }
        .devices {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .device-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            height: 30px; /* Fixed height for collapsed cards */
            overflow: hidden; /* Hide overflow content */
        }
        .device-card.active {
            height: auto; /* Allow active cards to expand */
            overflow: visible; /* Show all content */
        }
        .device-card:hover {
            transform: translateY(-2px);
        }
        .device-details {
            display: none !important;
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .device-card.active .device-details {
            display: block !important;
        }
        .status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status.online {
            background-color: #28a745;
        }
        .status.offline {
            background-color: #dc3545;
        }
        h1 {
            color: #1a73e8;
            margin: 0;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .live-link {
            padding: 10px 20px;
            background-color: #1a73e8;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .live-link:hover {
            background-color: #1557b0;
        }
        .data-row {
            margin: 8px 0;
            font-family: monospace;
        }
        .data-label {
            font-weight: bold;
            color: #666;
        }
        .timestamp {
            font-size: 0.8em;
            color: #666;
            position: absolute;
            top: 15px;
            right: 15px;
        }
        .map-container {
            height: 200px;
            margin: 10px 0;
            border-radius: 4px;
            overflow: hidden;
        }
        .chart-container {
            height: 150px;
            margin: 10px 0;
        }
        .card-header {
            display: flex;
            align-items: center;
            position: relative;
        }
        .card-header strong {
            margin-left: 5px;
        }
        .camera-container {
            margin: 10px 0;
            border-radius: 4px;
            overflow: hidden;
            max-height: 250px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Connected Devices</h1>
        <a href="/history.html" class="live-link">View History</a>
    </div>
    <div class="devices" id="devices"></div>

    <script>
        const ws = new WebSocket('ws://192.168.1.42:3000');
        const devicesContainer = document.getElementById('devices');
        const deviceStates = new Map(); // Store expanded state of devices
        const deviceData = new Map(); // Store historical data for charts
        const deviceMaps = new Map(); // Store map instances
        const deviceCharts = new Map(); // Store chart instances
        const expandedDevices = new Set(); // Track all expanded devices

        // Add this to your ws.onmessage handler

        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                console.log(`ðŸ“¨ Received WebSocket message of type: ${data.type}`);
                
                if (data.type === 'devices') {
                    // Count devices with camera data
                    const devicesWithCamera = data.devices.filter(d => d.data && d.data.camera).length;
                    console.log(`ðŸ“Š Received ${data.devices.length} devices, ${devicesWithCamera} with camera data`);
                    
                    updateDevices(data.devices);
                }
            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
            }
        };

        // Replace the updateDevices function with this improved version
        function updateDevices(devices) {
            // Log the raw device data for debugging
            console.log('Received devices update:', devices);
            
            // Keep track of existing devices to handle removals
            const existingDeviceIds = new Set(
                Array.from(document.querySelectorAll('.device-card'))
                    .map(card => card.getAttribute('data-device-id'))
            );
            
            // Process each device
            devices.forEach(device => {
                // Check if camera data exists
                if (device.data && device.data.camera) {
                    console.log(`Device ${device.deviceId} has camera data!`, 
                                `Image data length: ${device.data.camera.image.length}`);
                }
                
                const lastUpdate = new Date(device.data.lastUpdate);
                const isOnline = new Date() - lastUpdate < 10000;
                const deviceId = device.deviceId;
                
                // Initialize data structure if new device
                if (!deviceData.has(deviceId)) {
                    deviceData.set(deviceId, {
                        accelerometer: [],
                        locations: [],
                        timestamps: []
                    });
                }
                
                // Add new data point if available
                const deviceHistory = deviceData.get(deviceId);
                
                if (device.data.accelerometer) {
                    deviceHistory.accelerometer.push({
                        x: device.data.accelerometer.x,
                        y: device.data.accelerometer.y,
                        z: device.data.accelerometer.z
                    });
                    
                    // Also store location with each data point
                    if (device.data.location) {
                        deviceHistory.locations.push({
                            latitude: device.data.location.latitude,
                            longitude: device.data.location.longitude
                        });
                    } else {
                        // Use previous location or null if no location data
                        deviceHistory.locations.push(
                            deviceHistory.locations.length > 0 ? 
                            deviceHistory.locations[deviceHistory.locations.length - 1] : null
                        );
                    }
                    
                    deviceHistory.timestamps.push(lastUpdate);
                    
                    // Limit history to 20 points
                    if (deviceHistory.accelerometer.length > 20) {
                        deviceHistory.accelerometer.shift();
                        deviceHistory.locations.shift();
                        deviceHistory.timestamps.shift();
                    }
                }
                
                // Generate a friendly name
                const deviceName = `Device ${deviceId.substring(0, 6)}`;
                
                // Update existing card or create new one
                let card = document.querySelector(`.device-card[data-device-id="${deviceId}"]`);
                if (card) {
                    // Just update the status and timestamp
                    const statusEl = card.querySelector('.status');
                    if (statusEl) {
                        statusEl.className = `status ${isOnline ? 'online' : 'offline'}`;
                    }
                    
                    const timestampEl = card.querySelector('.timestamp');
                    if (timestampEl) {
                        timestampEl.textContent = formatTimestamp(lastUpdate);
                    }
                    
                    // Only this block should remain - it sets active class based on expandedDevices
                    if (expandedDevices.has(deviceId)) {
                        card.classList.add('active');
                        
                        // Update display data when expanded
                        const detailsContainer = card.querySelector('.device-details');
                        if (detailsContainer) {
                            const locationDetailsEl = detailsContainer.querySelector('.location-data');
                            if (locationDetailsEl && device.data.location) {
                                locationDetailsEl.innerHTML = `
                                    Latitude: ${device.data.location.latitude.toFixed(6)}<br>
                                    Longitude: ${device.data.location.longitude.toFixed(6)}
                                `;
                            }
                            
                            const accelDetailsEl = detailsContainer.querySelector('.accelerometer-data');
                            if (accelDetailsEl && device.data.accelerometer) {
                                accelDetailsEl.innerHTML = `
                                    X: ${device.data.accelerometer.x.toFixed(2)} m/sÂ²<br>
                                    Y: ${device.data.accelerometer.y.toFixed(2)} m/sÂ²<br>
                                    Z: ${device.data.accelerometer.z.toFixed(2)} m/sÂ²
                                `;
                            }
                            
                            // Update visualizations if expanded
                            updateMapAndChart(deviceId, device.data);
                        }
                    } else {
                        // Make sure it's NOT active if not in the set
                        card.classList.remove('active');
                    }
                    
                    // Directly set display style based on expandedDevices
                    const detailsContainer = card.querySelector('.device-details');
                    if (detailsContainer) {
                        detailsContainer.style.display = expandedDevices.has(deviceId) ? 'block' : 'none';
                    }
                    
                    existingDeviceIds.delete(deviceId);
                } else {
                    // Create new card for device
                    card = document.createElement('div');
                    // Set active class based on expandedDevices set
                    card.className = `device-card ${expandedDevices.has(deviceId) ? 'active' : ''}`;
                    card.setAttribute('data-device-id', deviceId);
                    card.onclick = function() { toggleDevice(this); };
                    
                    // Update card HTML to have a header section
                    card.innerHTML = `
                        <div class="card-header">
                            <span class="status ${isOnline ? 'online' : 'offline'}"></span>
                            <strong>${deviceName}</strong>
                            <span class="timestamp">${formatTimestamp(lastUpdate)}</span>
                        </div>
                        <div class="device-details">
                            ${formatDeviceData(device.data, deviceId)}
                        </div>
                    `;
                    
                    devicesContainer.appendChild(card);
                    
                    // Initialize map and chart if expanded
                    if (expandedDevices.has(deviceId)) {
                        setTimeout(() => {
                            initializeMapAndChart(deviceId, device.data);
                        }, 100);
                    }
                    
                    // After appending to DOM, set display explicitly
                    setTimeout(() => {
                        const newDetailsContainer = card.querySelector('.device-details');
                        if (newDetailsContainer) {
                            newDetailsContainer.style.display = expandedDevices.has(deviceId) ? 'block' : 'none';
                        }
                    }, 0);
                }
            });
            
            // Remove cards for disconnected devices
            existingDeviceIds.forEach(deviceId => {
                const oldCard = document.querySelector(`.device-card[data-device-id="${deviceId}"]`);
                if (oldCard) {
                    oldCard.remove();
                }
                // Clean up resources
                if (deviceMaps.has(deviceId)) {
                    deviceMaps.get(deviceId).remove();
                    deviceMaps.delete(deviceId);
                }
                if (deviceCharts.has(deviceId)) {
                    deviceCharts.get(deviceId).destroy();
                    deviceCharts.delete(deviceId);
                }
                deviceData.delete(deviceId);
                // Remove from expanded set too
                expandedDevices.delete(deviceId);
            });
        }

        // New function to update maps and charts without recreation
        function updateMapAndChart(deviceId, data) {
            // Update map if it exists
            if (data && data.location && deviceMaps.has(deviceId)) {
                const map = deviceMaps.get(deviceId);
                const newLatLng = [data.location.latitude, data.location.longitude];
                
                // Find and update marker or create new one
                let marker = map._deviceMarker;
                if (!marker) {
                    marker = L.marker(newLatLng).addTo(map);
                    map._deviceMarker = marker;
                } else {
                    marker.setLatLng(newLatLng);
                }
                
                // Smoothly pan to new location
                map.panTo(newLatLng, { animate: true, duration: 0.5 });
            }
            
            // Update chart with new data points
            if (data && data.accelerometer && deviceCharts.has(deviceId)) {
                const chart = deviceCharts.get(deviceId);
                const deviceHistory = deviceData.get(deviceId);
                
                if (deviceHistory && deviceHistory.accelerometer.length > 0) {
                    const labels = deviceHistory.timestamps.map(t => t.toLocaleTimeString());
                    
                    chart.data.labels = labels;
                    chart.data.datasets[0].data = deviceHistory.accelerometer.map(a => a.x);
                    chart.data.datasets[1].data = deviceHistory.accelerometer.map(a => a.y);
                    chart.data.datasets[2].data = deviceHistory.accelerometer.map(a => a.z);
                    
                    chart.update('none'); // Use 'none' for smoother updates without animation
                }
            }
            
            // Update camera image if available
            if (data && data.camera && data.camera.image) {
                if (validateCameraData(deviceId, data.camera.image)) {
                    const cameraImg = document.getElementById(`camera-${deviceId}`);
                    if (cameraImg) {
                        cameraImg.src = `data:image/jpeg;base64,${data.camera.image}`;
                    }
                }
            }
        }

        // Add this helper function

        function validateCameraData(deviceId, imageData) {
            // Check if base64 string is valid
            try {
                if (!imageData || imageData.length < 100) {
                    console.warn(`âš ï¸ Camera image data for ${deviceId} is too small: ${imageData?.length} bytes`);
                    return false;
                }
                
                // Try to create a sample image element to verify data
                const img = new Image();
                img.src = `data:image/jpeg;base64,${imageData}`;
                
                return true;
            } catch (e) {
                console.error(`âŒ Invalid camera data for ${deviceId}:`, e);
                return false;
            }
        }

        // Update the formatDeviceData function to add classes for easier updates
        function formatDeviceData(data, deviceId) {
            if (!data) return '';
            
            let html = '';
            
            // Add camera feed if available
            if (data.camera && data.camera.image) {
                const timestamp = new Date().getTime(); // Force browser to reload image
                console.log(`âœ… Formatting camera data for device ${deviceId}, image length: ${data.camera.image.length}`);
                
                html += `
                    <div class="data-row">
                        <span class="data-label">Camera:</span>
                        <div class="camera-container">
                            <img id="camera-${deviceId}" 
                                 src="data:image/jpeg;base64,${data.camera.image}?t=${timestamp}" 
                                 alt="Camera feed" 
                                 width="100%"
                                 onload="console.log('Camera image loaded for ${deviceId}')"
                                 onerror="console.error('Failed to load camera image for ${deviceId}')">
                        </div>
                    </div>
                `;
            }
            
            if (data.location) {
                html += `
                    <div class="data-row">
                        <span class="data-label">Location:</span><br>
                        <div class="location-data">
                            Latitude: ${data.location.latitude.toFixed(6)}<br>
                            Longitude: ${data.location.longitude.toFixed(6)}
                        </div>
                    </div>
                    <div class="map-container" id="map-${deviceId}"></div>
                `;
            }
            
            if (data.accelerometer) {
                html += `
                    <div class="data-row">
                        <span class="data-label">Accelerometer:</span><br>
                        <div class="accelerometer-data">
                            X: ${data.accelerometer.x.toFixed(2)} m/sÂ²<br>
                            Y: ${data.accelerometer.y.toFixed(2)} m/sÂ²<br>
                            Z: ${data.accelerometer.z.toFixed(2)} m/sÂ²
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="chart-${deviceId}"></canvas>
                    </div>
                `;
            }
            
            return html;
        }

        function initializeMapAndChart(deviceId, data) {
            // Initialize map if location data is available
            if (data && data.location) {
                const mapContainer = document.getElementById(`map-${deviceId}`);
                if (mapContainer) {
                    // Clear existing map instance if it exists
                    if (deviceMaps.has(deviceId)) {
                        deviceMaps.get(deviceId).remove();
                    }
                    
                    const map = L.map(mapContainer).setView(
                        [data.location.latitude, data.location.longitude], 
                        16
                    );
                    
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: 'Â© OpenStreetMap contributors'
                    }).addTo(map);
                    
                    L.marker([data.location.latitude, data.location.longitude]).addTo(map);
                    
                    deviceMaps.set(deviceId, map);
                }
            }
            
            // Initialize chart if accelerometer data is available
            if (data && data.accelerometer) {
                const chartCanvas = document.getElementById(`chart-${deviceId}`);
                if (chartCanvas) {
                    // Clear existing chart instance if it exists
                    if (deviceCharts.has(deviceId)) {
                        deviceCharts.get(deviceId).destroy();
                    }
                    
                    const deviceHistory = deviceData.get(deviceId);
                    if (deviceHistory && deviceHistory.accelerometer.length > 0) {
                        const labels = deviceHistory.timestamps.map(t => t.toLocaleTimeString());
                        const xData = deviceHistory.accelerometer.map(a => a.x);
                        const yData = deviceHistory.accelerometer.map(a => a.y);
                        const zData = deviceHistory.accelerometer.map(a => a.z);
                        
                        const chart = new Chart(chartCanvas, {
                            type: 'line',
                            data: {
                                labels: labels,
                                datasets: [
                                    {
                                        label: 'X',
                                        data: xData,
                                        borderColor: 'red',
                                        tension: 0.1
                                    },
                                    {
                                        label: 'Y',
                                        data: yData,
                                        borderColor: 'green',
                                        tension: 0.1
                                    },
                                    {
                                        label: 'Z',
                                        data: zData,
                                        borderColor: 'blue',
                                        tension: 0.1
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        beginAtZero: false
                                    }
                                }
                            }
                        });
                        
                        deviceCharts.set(deviceId, chart);
                    }
                }
            }
        }

        function formatTimestamp(date) {
            return date.toLocaleTimeString();
        }

        // Fix the toggleDevice function to explicitly manage display
        function toggleDevice(element) {
            const deviceId = element.getAttribute('data-device-id');
            const wasInactive = !element.classList.contains('active');
            
            // Toggle this panel's state only
            element.classList.toggle('active');
            
            // Get the details container and directly set its style
            const detailsContainer = element.querySelector('.device-details');
            if (detailsContainer) {
                // Set display explicitly based on active state
                detailsContainer.style.display = wasInactive ? 'block' : 'none';
            }
            
            if (wasInactive) {
                // Add to expanded set
                expandedDevices.add(deviceId);
                
                // Initialize visualizations
                setTimeout(() => {
                    initializeMapAndChart(deviceId, findDeviceDataById(deviceId));
                }, 100);
            } else {
                // Remove from expanded set
                expandedDevices.delete(deviceId);
                
                // Clean up resources for this device
                if (deviceMaps.has(deviceId)) {
                    deviceMaps.get(deviceId).remove();
                    deviceMaps.delete(deviceId);
                }
                if (deviceCharts.has(deviceId)) {
                    deviceCharts.get(deviceId).destroy();
                    deviceCharts.delete(deviceId);
                }
            }
        }

        // Helper function to get device data from our current state
        function findDeviceDataById(deviceId) {
            // If we have data history for this device
            const history = deviceData.get(deviceId);
            if (!history || history.accelerometer.length === 0) {
                return null;
            }
            
            const lastIndex = history.accelerometer.length - 1;
            
            // Return both the most recent accelerometer and location data
            return {
                accelerometer: history.accelerometer[lastIndex],
                location: history.locations[lastIndex]
            };
        }

        ws.onclose = () => {
            console.log('WebSocket connection closed');
            // Attempt to reconnect after 5 seconds
            setTimeout(() => {
                window.location.reload();
            }, 5000);
        };

        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
    </script>
</body>
</html>
